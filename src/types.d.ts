/**
 * @packageDocumentation
 * @module types
 * @description Global and ambient type declarations for the KenmeiToAnilist Electron app, including Vite, Electron, and window augmentation.
 */

// TODO: Update JSDoc comments

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Vite
// plugin that tells the Electron app where to look for the Vite-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_VITE_DEV_SERVER_URL: string | undefined;
declare const MAIN_WINDOW_VITE_NAME: string;

import type { APICredentials, TokenExchangeResponse } from "./types/auth";
import type { TokenExchangeParams } from "./types/api";
import type { IpcLogEntry } from "./types/debug";
import type { AniListRequest } from "./helpers/ipc/api/api-context";
import type { MangaSource } from "./api/manga-sources/types";

/**
 * Theme mode control interface.
 * @source
 */
interface ThemeModeContext {
  toggle: () => Promise<boolean>;
  dark: () => Promise<void>;
  light: () => Promise<void>;
  system: () => Promise<boolean>;
  current: () => Promise<"dark" | "light" | "system">;
}

/**
 * Electron window control methods for the renderer process.
 * @source
 */
interface ElectronWindow {
  minimize: () => Promise<void>;
  maximize: () => Promise<void>;
  close: () => Promise<void>;
}

/**
 * IPC debugging bridge for monitoring Electron IPC communication.
 * @source
 */
interface ElectronIpcDebugBridge {
  ipc: {
    maxEntries: number;
    getEvents: () => IpcLogEntry[];
    subscribe: (callback: (entries: IpcLogEntry[]) => void) => () => void;
    clear: () => void;
    setEnabled: (value: boolean) => void;
    isEnabled: () => boolean;
  };
}

/**
 * Auto-updater interface for application updates.
 * Provides methods for checking, downloading, and installing updates.
 * @source
 */
interface ElectronUpdater {
  /**
   * Checks for available updates from the update server.
   * @param options Optional configuration for the check
   * @param options.allowPrerelease Whether to include prerelease versions (default: false)
   * @returns Promise with update availability and version information
   */
  checkForUpdates: (options?: { allowPrerelease?: boolean }) => Promise<{
    updateAvailable: boolean;
    version?: string;
    releaseNotes?: string;
    releaseDate?: string;
  }>;

  /**
   * Initiates download of an available update.
   * @returns Promise that resolves when download starts
   */
  downloadUpdate: () => Promise<void>;

  /**
   * Quits the application and installs the downloaded update.
   * @returns Promise that resolves before app quits
   */
  installUpdate: () => Promise<void>;

  /**
   * Subscribes to update available events.
   * @param callback Function to call when an update is available
   * @returns Function to unsubscribe from the event
   */
  onUpdateAvailable: (
    callback: (info: {
      version: string;
      releaseNotes: string;
      releaseDate: string;
    }) => void,
  ) => () => void;

  /**
   * Subscribes to download progress events.
   * @param callback Function to call with download progress updates
   * @returns Function to unsubscribe from the event
   */
  onDownloadProgress: (
    callback: (progress: {
      percent: number;
      bytesPerSecond: number;
      transferred: number;
      total: number;
    }) => void,
  ) => () => void;

  /**
   * Subscribes to update downloaded events.
   * @param callback Function to call when download is complete
   * @returns Function to unsubscribe from the event
   */
  onUpdateDownloaded: (
    callback: (info: { version: string }) => void,
  ) => () => void;

  /**
   * Subscribes to update error events.
   * @param callback Function to call when an update error occurs
   * @returns Function to unsubscribe from the event
   */
  onUpdateError: (
    callback: (error: {
      message: string;
      stack?: string;
      name?: string;
    }) => void,
  ) => () => void;
}

/**
 * Manga matching process state for UI synchronization.
 * @source
 */
interface MatchingProcessState {
  isRunning: boolean;
  progress: {
    current: number;
    total: number;
    currentTitle: string;
  };
  statusMessage: string;
  detailMessage: string | null;
  timeEstimate?: {
    startTime: number;
    averageTimePerManga: number;
    estimatedRemainingSeconds: number;
  };
  isManuallyPaused?: boolean;
  isPauseTransitioning?: boolean;
  lastUpdated: number;
}

declare global {
  interface ImportMeta {
    readonly env: {
      [key: string]: string | boolean | undefined;
      readonly VITE_ANILIST_CLIENT_ID: string;
      readonly VITE_ANILIST_CLIENT_SECRET: string;
      readonly VITE_APP_VERSION?: string;
      readonly VITE_SENTRY_DSN?: string;
      readonly VITE_ANILIST_ENCRYPTION_KEY?: string;
      readonly MODE: string;
      readonly DEV: boolean;
      readonly PROD: boolean;
    };
  }

  interface Window {
    themeMode: ThemeModeContext;
    electronWindow: ElectronWindow;
    electronAPI: {
      window: {
        minimize: () => Promise<void>;
        maximize: () => Promise<void>;
        close: () => Promise<void>;
      };
      theme: {
        setTheme: (theme: string) => Promise<void>;
        getTheme: () => Promise<string>;
      };
      anilist: {
        request: (payload: AniListRequest) => Promise<{
          success: boolean;
          data?: Record<string, unknown>;
          error?: {
            message: string;
            status?: number;
            errors?: Array<{ message: string }>;
          };
        }>;
        exchangeToken: (params: TokenExchangeParams) => Promise<{
          success: boolean;
          token?: {
            access_token: string;
            token_type: string;
            expires_in: number;
          };
          error?: string;
        }>;
        clearCache: (searchQuery?: string) => Promise<{ success: boolean }>;
        getRateLimitStatus: () => Promise<{
          isRateLimited: boolean;
          retryAfter: number | null;
          timeRemaining: number;
        }>;
      };
      mangaSource: {
        search: (
          source: MangaSource,
          query: string,
          limit?: number,
        ) => Promise<unknown>;
        getMangaDetail: (source: MangaSource, slug: string) => Promise<unknown>;
      };
      comick: {
        search: (query: string, limit?: number) => Promise<unknown>;
        getMangaDetail: (hid: string) => Promise<unknown>;
      };
      shell: {
        openExternal: (url: string) => Promise<void>;
      };
      electronStore: {
        getItem: (key: string) => Promise<string>;
        setItem: (key: string, value: string) => Promise<void>;
        removeItem: (key: string) => Promise<void>;
        clear: () => Promise<void>;
      };
    };
    electronAuth: {
      openOAuthWindow: (
        oauthUrl: string,
        redirectUri: string,
      ) => Promise<{ success: boolean; error?: string }>;
      storeCredentials: (
        credentials: APICredentials,
      ) => Promise<{ success: boolean; error?: string }>;
      getCredentials: (source: "default" | "custom") => Promise<{
        success: boolean;
        credentials?: APICredentials;
        error?: string;
      }>;
      onCodeReceived: (
        callback: (data: { code: string }) => void,
      ) => () => void;
      onStatus: (callback: (message: string) => void) => () => void;
      onCancelled: (callback: () => void) => () => void;
      cancelAuth: () => Promise<{ success: boolean; error?: string }>;
      exchangeToken: (data: {
        clientId: string;
        clientSecret: string;
        redirectUri: string;
        code: string;
      }) => Promise<TokenExchangeResponse>;
    };

    electronDebug?: ElectronIpcDebugBridge;
    electronUpdater: ElectronUpdater;

    // Custom application state properties
    matchingProcessState?: MatchingProcessState;
    activeAbortController?: AbortController;
  }

  // Define extensions to globalThis
  namespace globalThis {
    // eslint-disable-next-line no-var
    var themeMode: ThemeModeContext;
    // eslint-disable-next-line no-var
    var electronWindow: ElectronWindow;
    // eslint-disable-next-line no-var
    var electronAPI: Window["electronAPI"];
    // eslint-disable-next-line no-var
    var electronAuth: Window["electronAuth"];
    // eslint-disable-next-line no-var
    var electronDebug: Window["electronDebug"] | undefined;
    // eslint-disable-next-line no-var
    var electronUpdater: ElectronUpdater;
    // eslint-disable-next-line no-var
    var matchingProcessState: MatchingProcessState | undefined;
    // eslint-disable-next-line no-var
    var activeAbortController: AbortController | undefined;
    // eslint-disable-next-line no-var
    var electronStore: Window["electronAPI"]["electronStore"];
  }
}
