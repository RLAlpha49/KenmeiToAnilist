/**
 * @packageDocumentation
 * @module types
 * @description Global and ambient type declarations for the KenmeiToAnilist Electron app, including Vite, Electron, and window augmentation.
 */
// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Vite
// plugin that tells the Electron app where to look for the Vite-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_VITE_DEV_SERVER_URL: string | undefined;
declare const MAIN_WINDOW_VITE_NAME: string;

// Import types that are referenced in the global declarations
import type { APICredentials, TokenExchangeResponse } from "./types/auth";
import type { TokenExchangeParams } from "./types/api";
import type { IpcLogEntry } from "./types/debug";
import type { AniListRequest } from "./helpers/ipc/api/api-context";
import type { MangaSource } from "./api/manga-sources/types";

/**
 * Theme mode control interface.
 * @source
 */
interface ThemeModeContext {
  toggle: () => Promise<boolean>;
  dark: () => Promise<void>;
  light: () => Promise<void>;
  system: () => Promise<boolean>;
  current: () => Promise<"dark" | "light" | "system">;
}

/**
 * Electron window control methods for the renderer process.
 * @source
 */
interface ElectronWindow {
  minimize: () => Promise<void>;
  maximize: () => Promise<void>;
  close: () => Promise<void>;
}

/**
 * IPC debugging bridge for monitoring Electron IPC communication.
 * @source
 */
interface ElectronIpcDebugBridge {
  ipc: {
    maxEntries: number;
    getEvents: () => IpcLogEntry[];
    subscribe: (callback: (entries: IpcLogEntry[]) => void) => () => void;
    clear: () => void;
    setEnabled: (value: boolean) => void;
    isEnabled: () => boolean;
  };
}

/**
 * Manga matching process state for UI synchronization.
 * @source
 */
interface MatchingProcessState {
  isRunning: boolean;
  progress: {
    current: number;
    total: number;
    currentTitle: string;
  };
  statusMessage: string;
  detailMessage: string | null;
  timeEstimate?: {
    startTime: number;
    averageTimePerManga: number;
    estimatedRemainingSeconds: number;
  };
  isManuallyPaused?: boolean;
  isPauseTransitioning?: boolean;
  lastUpdated: number;
}

declare global {
  interface ImportMeta {
    readonly env: {
      [key: string]: string | boolean | undefined;
      readonly VITE_ANILIST_CLIENT_ID: string;
      readonly VITE_ANILIST_CLIENT_SECRET: string;
      readonly VITE_APP_VERSION?: string;
      readonly VITE_SENTRY_DSN?: string;
      readonly VITE_ANILIST_ENCRYPTION_KEY?: string;
      readonly MODE: string;
      readonly DEV: boolean;
      readonly PROD: boolean;
    };
  }

  interface Window {
    themeMode: ThemeModeContext;
    electronWindow: ElectronWindow;
    electronAPI: {
      window: {
        minimize: () => Promise<void>;
        maximize: () => Promise<void>;
        close: () => Promise<void>;
      };
      theme: {
        setTheme: (theme: string) => Promise<void>;
        getTheme: () => Promise<string>;
      };
      anilist: {
        request: (payload: AniListRequest) => Promise<{
          success: boolean;
          data?: Record<string, unknown>;
          error?: {
            message: string;
            status?: number;
            errors?: Array<{ message: string }>;
          };
        }>;
        exchangeToken: (params: TokenExchangeParams) => Promise<{
          success: boolean;
          token?: {
            access_token: string;
            token_type: string;
            expires_in: number;
          };
          error?: string;
        }>;
        clearCache: (searchQuery?: string) => Promise<{ success: boolean }>;
        getRateLimitStatus: () => Promise<{
          isRateLimited: boolean;
          retryAfter: number | null;
          timeRemaining: number;
        }>;
      };
      mangaSource: {
        search: (
          source: MangaSource,
          query: string,
          limit?: number,
        ) => Promise<unknown>;
        getMangaDetail: (source: MangaSource, slug: string) => Promise<unknown>;
      };
      comick: {
        search: (query: string, limit?: number) => Promise<unknown>;
        getMangaDetail: (hid: string) => Promise<unknown>;
      };
      shell: {
        openExternal: (url: string) => Promise<void>;
      };
      electronStore: {
        getItem: (key: string) => Promise<string>;
        setItem: (key: string, value: string) => Promise<void>;
        removeItem: (key: string) => Promise<void>;
        clear: () => Promise<void>;
      };
    };
    electronAuth: {
      openOAuthWindow: (
        oauthUrl: string,
        redirectUri: string,
      ) => Promise<{ success: boolean; error?: string }>;
      storeCredentials: (
        credentials: APICredentials,
      ) => Promise<{ success: boolean; error?: string }>;
      getCredentials: (source: "default" | "custom") => Promise<{
        success: boolean;
        credentials?: APICredentials;
        error?: string;
      }>;
      onCodeReceived: (
        callback: (data: { code: string }) => void,
      ) => () => void;
      onStatus: (callback: (message: string) => void) => () => void;
      onCancelled: (callback: () => void) => () => void;
      cancelAuth: () => Promise<{ success: boolean; error?: string }>;
      exchangeToken: (data: {
        clientId: string;
        clientSecret: string;
        redirectUri: string;
        code: string;
      }) => Promise<TokenExchangeResponse>;
    };

    electronDebug?: ElectronIpcDebugBridge;

    // Custom application state properties
    matchingProcessState?: MatchingProcessState;
    activeAbortController?: AbortController;
  }

  // Define extensions to globalThis
  namespace globalThis {
    // eslint-disable-next-line no-var
    var themeMode: ThemeModeContext;
    // eslint-disable-next-line no-var
    var electronWindow: ElectronWindow;
    // eslint-disable-next-line no-var
    var electronAPI: Window["electronAPI"];
    // eslint-disable-next-line no-var
    var electronAuth: Window["electronAuth"];
    // eslint-disable-next-line no-var
    var electronDebug: Window["electronDebug"] | undefined;
    // eslint-disable-next-line no-var
    var matchingProcessState: MatchingProcessState | undefined;
    // eslint-disable-next-line no-var
    var activeAbortController: AbortController | undefined;
    // eslint-disable-next-line no-var
    var electronStore: Window["electronAPI"]["electronStore"];
  }
}
