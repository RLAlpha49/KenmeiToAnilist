name: Beta Release

on:
  push:
    branches:
      - master
    paths-ignore:
      - ".github/**"
      - "docs/**"
      - "*.md"

permissions:
  contents: write

jobs:
  build-windows:
    name: Build Windows
    runs-on: windows-latest
    env:
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      NODE_ENV: production
      VITE_ANILIST_CLIENT_ID: ${{ secrets.ANILIST_CLIENT_ID }}
      VITE_ANILIST_CLIENT_SECRET: ${{ secrets.ANILIST_CLIENT_SECRET }}
      VITE_ANILIST_ENCRYPTION_KEY: ${{ secrets.ANILIST_ENCRYPTION_KEY }}
      SENTRY_DSN: ${{ secrets.SENTRY_DSN }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 22
      - name: Install dependencies
        env:
          NPM_CONFIG_PRODUCTION: false
        run: npm ci --force
      - name: Build / Make (Windows)
        run: npm run make
      - name: Upload Windows Build Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: windows-installers
          path: |
            out/make/squirrel.windows/x64/*.exe
            out/make/squirrel.windows/x64/*.msi
          if-no-files-found: warn

  build-macos:
    name: Build macOS
    runs-on: macos-latest
    env:
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      NODE_ENV: production
      VITE_ANILIST_CLIENT_ID: ${{ secrets.ANILIST_CLIENT_ID }}
      VITE_ANILIST_CLIENT_SECRET: ${{ secrets.ANILIST_CLIENT_SECRET }}
      VITE_ANILIST_ENCRYPTION_KEY: ${{ secrets.ANILIST_ENCRYPTION_KEY }}
      SENTRY_DSN: ${{ secrets.SENTRY_DSN }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 22
      - name: Install dependencies
        env:
          NPM_CONFIG_PRODUCTION: false
        run: npm ci --force
      - name: Build / Make (macOS)
        run: npm run make
      - name: Upload macOS Build Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: macos-installers
          path: |
            out/make/*.dmg
            out/make/zip/darwin/arm64/*.zip
          if-no-files-found: warn

  build-linux:
    name: Build Linux
    runs-on: ubuntu-latest
    env:
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      NODE_ENV: production
      VITE_ANILIST_CLIENT_ID: ${{ secrets.ANILIST_CLIENT_ID }}
      VITE_ANILIST_CLIENT_SECRET: ${{ secrets.ANILIST_CLIENT_SECRET }}
      VITE_ANILIST_ENCRYPTION_KEY: ${{ secrets.ANILIST_ENCRYPTION_KEY }}
      SENTRY_DSN: ${{ secrets.SENTRY_DSN }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 22
      - name: Install dependencies
        env:
          NPM_CONFIG_PRODUCTION: false
        run: npm ci --force
      - name: Build / Make (Linux)
        run: npm run make
      - name: Upload Linux Build Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: linux-installers
          path: |
            out/make/deb/x64/*.deb
          if-no-files-found: warn

  publish-beta:
    name: Publish Beta Release
    needs: [build-windows, build-macos, build-linux]
    runs-on: ubuntu-latest
    # If the incoming push commit message contains [skip ci], skip this job to avoid workflow loops
    if: ${{ !contains(github.event.head_commit.message, '[skip ci]') }}
    env:
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      NODE_ENV: production
      VITE_ANILIST_CLIENT_ID: ${{ secrets.ANILIST_CLIENT_ID }}
      VITE_ANILIST_CLIENT_SECRET: ${{ secrets.ANILIST_CLIENT_SECRET }}
      VITE_ANILIST_ENCRYPTION_KEY: ${{ secrets.ANILIST_ENCRYPTION_KEY }}
      SENTRY_DSN: ${{ secrets.SENTRY_DSN }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Download Windows installers
        uses: actions/download-artifact@v4
        with:
          name: windows-installers
          path: out/make/squirrel.windows/x64

      - name: Download macOS installers
        uses: actions/download-artifact@v4
        with:
          name: macos-installers
          path: out/make

      - name: Download Linux installers
        uses: actions/download-artifact@v4
        with:
          name: linux-installers
          path: out/make/deb/x64

      - name: Get version from package.json
        id: version
        run: |
          $version = (Get-Content package.json | ConvertFrom-Json).version
          echo "VERSION=$version" >> $env:GITHUB_OUTPUT
        shell: pwsh

      - name: Create or update beta release tag
        run: |
          $beta_tag = "v${{ steps.version.outputs.VERSION }}-beta"
          git tag -d "$beta_tag" 2>$null; $null
          git tag "$beta_tag"
          git push origin "$beta_tag" --force
        shell: pwsh

      - name: Create or update GitHub release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Determine behavior:
          # - If a non-prerelease release exists with the exact tag for the current package.json version (e.g. v3.0.0)
          #   then create/overwrite a prerelease by incrementing the patch (e.g. v3.0.1, v3.0.2, ...)
          # - Otherwise keep the existing beta behavior (v{version}-beta)

          $pkgVersion = "${{ steps.version.outputs.VERSION }}"
          $repo = '${{ github.repository }}'

          # Fetch releases as JSON
          $releasesJson = gh api "repos/$repo/releases" 2>$null
          if ($LASTEXITCODE -ne 0) {
            Write-Error "Failed to fetch releases via gh api"
            exit 1
          }
          $releases = $releasesJson | ConvertFrom-Json

          $exactTag = "v$pkgVersion"
          # Find a non-prerelease release with the exact tag
          $exactRelease = $releases | Where-Object { ($_.tag_name -eq $exactTag) -and (-not $_.prerelease) }

          function Write-ReleaseNotes {
            param($tagToUse)
            $full = git rev-parse HEAD
            $commit = git rev-parse --short HEAD
            $author = git show -s --format='%an' $full
            $date = git show -s --format='%ci' $full
            $message = git show -s --format='%s' $full
            $commit_url = "https://github.com/$repo/commit/$full"
            $run_url = "https://github.com/$repo/actions/runs/${{ github.run_id }}"
            $actor = '${{ github.actor }}'

            $md = @()
            $md += "# Beta Release - $tagToUse"
            $md += ""
            $md += "**Generated from commit**: [$commit]($commit_url)"
            $md += ""
            $md += "**Author:** $author"
            $md += "**Date:** $date"
            $md += ""
            $md += "**Commit message:**"
            $md += "```"
            $md += "$message"
            $md += "```"
            $md += ""
            $md += "**CI Run:** [$run_url]($run_url) by $actor"
            $md += ""
            $md += "---"
            $md += "_This is an automated beta/prerelease generated by the CI pipeline._"

            $md | Out-File -FilePath release_notes.md -Encoding utf8
          }

          if ($exactRelease) {
            # Package version was already released as a normal release. Create an incremented patch prerelease.
            if ($pkgVersion -match '^([0-9]+)\.([0-9]+)\.([0-9]+)$') {
              $major = $matches[1]
              $minor = $matches[2]
              $patch = [int]$matches[3]
            } else {
              Write-Error "Package version '$pkgVersion' is not in x.y.z format. Aborting."
              exit 1
            }

            # Find existing tags/releases matching the same major.minor (e.g. v3.0.1, v3.0.2)
            $pattern = "^v$major\.$minor\.(\d+)$"
            $matching = $releases | Where-Object { $_.tag_name -match $pattern }

            if ($matching) {
              $patches = $matching | ForEach-Object { [int]($_.tag_name -replace "^v$major\.$minor\.", '') }
              $maxPatch = ($patches | Measure-Object -Maximum).Maximum
              if (-not $maxPatch) { $maxPatch = 0 }
              $nextPatch = $maxPatch + 1
            } else {
              # No prereleases exist for this minor, start at patch+1
              $nextPatch = $patch + 1
            }

            $newTag = "v$major.$minor.$nextPatch"

            # Update package.json version to match the new prerelease and commit it (use [skip ci] to avoid workflow loops)
            $updatedVersion = "${major}.${minor}.${nextPatch}"
            Write-Host "Updating package.json to $updatedVersion"
            if (Test-Path package.json) {
              $pkg = Get-Content package.json -Raw | ConvertFrom-Json
              if ($pkg.version -ne $updatedVersion) {
                $pkg.version = $updatedVersion
                $pkg | ConvertTo-Json -Depth 100 | Out-File -FilePath package.json -Encoding utf8
                git add package.json
                git config user.email "${{ github.actor }}@users.noreply.github.com"
                git config user.name "${{ github.actor }}"
                git commit -m "chore: bump package.json to v$updatedVersion [skip ci]" || $null
                # Push the commit back to the default branch. Using GITHUB_TOKEN via checkout action credentials.
                git push origin HEAD:refs/heads/${{ github.ref_name }} || git push origin HEAD:master
              } else {
                Write-Host "package.json already at $updatedVersion, no commit needed"
              }
            } else {
              Write-Host "package.json not found; skipping update"
            }

            # Update git tag (overwrite if exists) on the new commit (if any)
            git tag -d $newTag 2>$null; $null
            git tag $newTag
            git push origin $newTag --force

            # Write notes, delete existing release (if any), then create prerelease with artifacts
            Write-ReleaseNotes $newTag
            $existing = gh release view $newTag 2>$null
            if ($LASTEXITCODE -eq 0) { gh release delete $newTag --yes }

            gh release create "$newTag" `
              --prerelease `
              --title "$newTag" `
              --notes-file release_notes.md `
              out/make/squirrel.windows/x64/*.exe `
              out/make/squirrel.windows/x64/*.msi `
              out/make/*.dmg `
              out/make/zip/darwin/arm64/*.zip `
              out/make/deb/x64/*.deb
          } else {
            # No exact release for the package version exists — preserve previous beta behavior
            $beta_tag = "v$pkgVersion-beta"
            git tag -d "$beta_tag" 2>$null; $null
            git tag "$beta_tag"
            git push origin "$beta_tag" --force

            Write-ReleaseNotes $beta_tag
            $release = gh release view "$beta_tag" 2>$null
            if ($LASTEXITCODE -eq 0) {
              gh release delete "$beta_tag" --yes
            }

            gh release create "$beta_tag" `
              --prerelease `
              --title "$beta_tag" `
              --notes-file release_notes.md `
              out/make/squirrel.windows/x64/*.exe `
              out/make/squirrel.windows/x64/*.msi `
              out/make/*.dmg `
              out/make/zip/darwin/arm64/*.zip `
              out/make/deb/x64/*.deb
          }
        shell: pwsh
