name: Delete All Old Artifacts Comprehensive

on:
  workflow_dispatch:
  schedule:
    - cron: '0 0 * * 0'

jobs:
  cleanup:
    runs-on: ubuntu-latest
    steps:
      - name: Delete artifacts comprehensively
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ARTIFACT_DELETE_TOKEN: ${{ secrets.ARTIFACT_DELETE_TOKEN }}
        run: |
          #!/bin/bash
          set -euo pipefail

          owner_repo="${GITHUB_REPOSITORY}"
          echo "Repository: $owner_repo"

          echo "Fetching all existing branches..."
          # Get a list of all existing branches
          # Using a temporary file for branches for easier lookup
          temp_branches_file=$(mktemp)
          
          page=1
          while true; do
            branches_json=$(curl -s -H "Authorization: token $GITHUB_TOKEN" \
              "https://api.github.com/repos/${owner_repo}/branches?per_page=100&page=${page}")
            current_page_branches=$(echo "$branches_json" | jq -r '.[].name')
            if [ -z "$current_page_branches" ]; then
              break
            fi
            echo "$current_page_branches" >> "$temp_branches_file"
            page=$((page + 1))
          done

          # Store existing branch names in a hash for quick lookups
          all_existing_branches=$(cat "$temp_branches_file" | sort -u)
          echo "Found $(echo "$all_existing_branches" | wc -l) existing branches."

          echo "Fetching all workflow runs..."
          # Fetch ALL workflow runs (potentially across multiple pages)
          # We need to check runs regardless of their current branch status
          all_runs_json=""
          page=1
          while true; do
            runs_response=$(curl -s -H "Authorization: token $GITHUB_TOKEN" \
              "https://api.github.com/repos/${owner_repo}/actions/runs?per_page=100&page=${page}")
            
            # Check if runs_response is empty or malformed
            if echo "$runs_response" | jq -e 'has("workflow_runs")' > /dev/null; then
              current_page_runs=$(echo "$runs_response" | jq '.workflow_runs')
              if [ "$(echo "$current_page_runs" | jq 'length')" -eq 0 ]; then
                break # No more runs
              fi
              all_runs_json=$(echo "$all_runs_json" "$current_page_runs" | jq -s 'add | unique_by(.id)')
              # If first page, initialize, else add to existing
              if [ -z "$(echo "$all_runs_json" | jq '.[]?')" ]; then
                  all_runs_json=$(echo "$runs_response" | jq '.workflow_runs')
              else
                  all_runs_json=$(echo "$all_runs_json" "$current_page_runs" | jq -s 'add | unique_by(.id)')
              fi
              
            else
                echo "Warning: API response for runs page $page was not as expected. Breaking loop."
                break
            fi
            page=$((page + 1))
          done

          if [ -z "$all_runs_json" ] || [ "$(echo "$all_runs_json" | jq 'length')" -eq 0 ]; then
            echo "No workflow runs found. Nothing to clean."
            rm "$temp_branches_file"
            exit 0
          fi

          echo "Found $(echo "$all_runs_json" | jq 'length') total workflow runs to analyze."

          # Get a list of the latest "CI Suite" run SHA for each existing branch
          declare -A latest_ci_shas_per_branch
          for branch_name in $all_existing_branches; do
            latest_ci_run_for_branch=$(echo "$all_runs_json" | jq -r --arg bn "$branch_name" \
              '.[] | select(.head_branch == $bn and .status=="completed" and .name=="CI Suite") | .head_sha' | head -n 1)
            if [ -n "$latest_ci_run_for_branch" ]; then
              latest_ci_shas_per_branch["$branch_name"]="$latest_ci_run_for_branch"
              echo "  Latest CI Suite SHA for $branch_name: $latest_ci_run_for_branch"
            fi
          done
          
          # Convert Bash associative array to a JSON string
          latest_shas_map_json="{"
          first=true
          for branch in "${!latest_ci_shas_per_branch[@]}"; do
            if [ "$first" = false ]; then
              latest_shas_map_json+=","
            fi
            # Escape keys and values for JSON
            escaped_branch=$(printf %s "$branch" | jq -sRr @json)
            escaped_sha=$(printf %s "${latest_ci_shas_per_branch[$branch]}" | jq -sRr @json)
            latest_shas_map_json+="\"$escaped_branch\": $escaped_sha"
            first=false
          done
          latest_shas_map_json+="}"

          echo "Identifying runs for deletion..."
          
          runs_to_delete_output=$(echo "$all_runs_json" | jq -r --argjson latest_shas_map "$latest_shas_map_json" \
              '.[] | select(.name=="CI Suite" and .status=="completed") | 
              {id: .id, branch: .head_branch, sha: .head_sha} |
              if ($latest_shas_map | has(.branch)) then # Check if branch exists as a key in the map
                  # Branch exists, check if this is an old run
                  .branch as $b | $latest_shas_map[$b] as $latest_sha_for_branch |
                  if .sha != $latest_sha_for_branch then
                      "\(.id) Older run on existing branch \(.branch) (\(.sha))"
                  else
                      empty # Keep current/latest runs
                  end
              else
                  # Branch does not exist, delete all CI Suite artifacts from this run
                  "\(.id) Branch no longer exists \(.branch) (\(.sha))"
              end'
          )

          # Now process the identified runs to build the delete_run_ids list
          delete_run_ids=""
          if [ -n "$runs_to_delete_output" ]; then
              echo "$runs_to_delete_output" | while read -r line; do
                  run_id=$(echo "$line" | cut -d' ' -f1)
                  # Print the "Marking run ID..." message for logging
                  echo "  Marking run ID $line for deletion." 
                  delete_run_ids+=" $run_id"
              done
          fi

          if [ -z "$delete_run_ids" ]; then
            echo "No workflow runs identified for deletion."
            rm "$temp_branches_file"
            exit 0
          fi

          # Process unique run IDs for deletion
          delete_run_ids=$(echo "$delete_run_ids" | tr ' ' '\n' | sort -u | grep -v '^\s*$' | tr '\n' ' ')
          echo "Found $(echo "$delete_run_ids" | wc -w) unique workflow runs to clean up."

          for run_id in $delete_run_ids; do
            echo "Processing workflow run ID: $run_id"

            # List artifacts in this workflow run
            artifacts_json=$(curl -s -H "Authorization: token $GITHUB_TOKEN" \
              "https://api.github.com/repos/${owner_repo}/actions/runs/${run_id}/artifacts")
            artifact_ids=$(echo "$artifacts_json" | jq --raw-output '.artifacts[] | .id')

            if [ -z "$artifact_ids" ]; then
              echo "No artifacts found for run $run_id"
              continue
            fi

            for artifact_id in $artifact_ids; do
              echo "Deleting artifact ID: $artifact_id from run $run_id"
              curl -s -X DELETE -H "Authorization: token ${ARTIFACT_DELETE_TOKEN}" \
                "https://api.github.com/repos/${owner_repo}/actions/artifacts/${artifact_id}"
            done
          done

          rm "$temp_branches_file"
          echo "Cleanup complete."
