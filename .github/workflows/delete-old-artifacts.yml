name: Delete All Old Artifacts Comprehensive

on:
  workflow_dispatch:
  schedule:
    - cron: "0 0 * * 0"

jobs:
  cleanup:
    runs-on: ubuntu-latest
    steps:
      - name: Delete artifacts comprehensively
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ARTIFACT_DELETE_TOKEN: ${{ secrets.ARTIFACT_DELETE_TOKEN }}
        run: |
          #!/bin/bash
          set -euo pipefail

          owner_repo="${GITHUB_REPOSITORY}"
          echo "Repository: $owner_repo"

          echo "Fetching all existing branches..."
          # Get a list of all existing branches
          # Using a temporary file for branches for easier lookup
          temp_branches_file=$(mktemp)

          page=1
          while true; do
            branches_json=$(curl -s -H "Authorization: token $GITHUB_TOKEN" \
              "https://api.github.com/repos/${owner_repo}/branches?per_page=100&page=${page}")
            current_page_branches=$(echo "$branches_json" | jq -r '.[].name')
            if [ -z "$current_page_branches" ]; then
              break
            fi
            echo "$current_page_branches" >> "$temp_branches_file"
            page=$((page + 1))
          done

          # Store existing branch names in a hash for quick lookups
          all_existing_branches=$(cat "$temp_branches_file" | sort -u)
          echo "Found $(echo "$all_existing_branches" | wc -l) existing branches."

          echo "Fetching all workflow runs..."
          # Fetch ALL workflow runs (potentially across multiple pages)
          # We need to check runs regardless of their current branch status
          temp_runs_file=$(mktemp)
          page=1
          total_runs=0

          while true; do
            echo "  Fetching page $page..."
            runs_response=$(curl -s -H "Authorization: token $GITHUB_TOKEN" \
              "https://api.github.com/repos/${owner_repo}/actions/runs?per_page=100&page=${page}")
            
            # Check if runs_response is empty or malformed
            if ! echo "$runs_response" | jq -e 'has("workflow_runs")' > /dev/null; then
                echo "Warning: API response for runs page $page was not as expected. Breaking loop."
                break
            fi
            
            current_page_runs=$(echo "$runs_response" | jq '.workflow_runs')
            page_length=$(echo "$current_page_runs" | jq 'length')
            
            if [ "$page_length" -eq 0 ]; then
                break # No more runs
            fi
            
            # Append runs to temp file (much faster than JSON manipulation)
            echo "$current_page_runs" | jq -r '.[] | @json' >> "$temp_runs_file"
            total_runs=$((total_runs + page_length))
            echo "    Got $page_length runs (total: $total_runs)"
            
            page=$((page + 1))
          done

          # Combine all runs into single JSON array at the end
          if [ ! -s "$temp_runs_file" ]; then
            echo "No workflow runs found. Nothing to clean."
            rm "$temp_branches_file" "$temp_runs_file"
            exit 0
          fi

          echo "Combining $total_runs workflow runs..."
          all_runs_json=$(cat "$temp_runs_file" | jq -s 'unique_by(.id)')
          rm "$temp_runs_file"

          if [ -z "$all_runs_json" ] || [ "$(echo "$all_runs_json" | jq 'length')" -eq 0 ]; then
            echo "No workflow runs found. Nothing to clean."
            rm "$temp_branches_file"
            exit 0
          fi

          echo "Found $(echo "$all_runs_json" | jq 'length') total workflow runs to analyze."

          # Get a list of the latest "CI Suite" run SHA for each existing branch
          declare -A latest_ci_shas_per_branch
          for branch_name in $all_existing_branches; do
            latest_ci_run_for_branch=$(echo "$all_runs_json" | jq -r --arg bn "$branch_name" \
              '.[] | select(.head_branch == $bn and .status=="completed" and .name=="CI Suite") | .head_sha' | head -n 1)
            if [ -n "$latest_ci_run_for_branch" ]; then
              latest_ci_shas_per_branch["$branch_name"]="$latest_ci_run_for_branch"
              echo "  Latest CI Suite SHA for $branch_name: $latest_ci_run_for_branch"
            fi
          done

          # Convert Bash associative array to a JSON string
          echo "Building latest SHA map for branches..."
          latest_shas_map_json="{}"
          if [ ${#latest_ci_shas_per_branch[@]} -gt 0 ]; then
            # Use jq to build the JSON properly to avoid escaping issues
            temp_json_file=$(mktemp)
            echo "{}" > "$temp_json_file"
            
            for branch in "${!latest_ci_shas_per_branch[@]}"; do
              echo "  Processing branch: $branch"
              # Use jq to safely add each branch/SHA pair
              jq --arg branch "$branch" --arg sha "${latest_ci_shas_per_branch[$branch]}" \
                '. + {($branch): $sha}' "$temp_json_file" > "${temp_json_file}.tmp" && mv "${temp_json_file}.tmp" "$temp_json_file"
            done
            
            latest_shas_map_json=$(cat "$temp_json_file")
            rm "$temp_json_file"
          fi

          echo "Latest SHA map: $latest_shas_map_json"

          echo "Identifying runs for deletion..."

          runs_to_delete_output=$(echo "$all_runs_json" | jq -r --argjson latest_shas_map "$latest_shas_map_json" \
              '.[] | select(.name=="CI Suite" and .status=="completed") | 
              {id: .id, branch: .head_branch, sha: .head_sha} |
              if .branch == null then
                  # Branch is null, delete this run
                  "\(.id) Branch is null (\(.sha))"
              elif ($latest_shas_map | has(.branch)) then
                  # Branch exists in map, check if this is an old run
                  .branch as $b | $latest_shas_map[$b] as $latest_sha_for_branch |
                  if .sha != $latest_sha_for_branch then
                      "\(.id) Older run on existing branch \(.branch) (\(.sha))"
                  else
                      empty # Keep current/latest runs
                  end
              else
                  # Branch does not exist in map, delete this run
                  "\(.id) Branch no longer exists \(.branch) (\(.sha))"
              end'
          )

          # Now process the identified runs to build the delete_run_ids list
          delete_run_ids=""
          if [ -n "$runs_to_delete_output" ]; then
              echo "$runs_to_delete_output" | while read -r line; do
                  run_id=$(echo "$line" | cut -d' ' -f1)
                  # Print the "Marking run ID..." message for logging
                  echo "  Marking run ID $line for deletion." 
                  delete_run_ids+=" $run_id"
              done
          fi

          if [ -z "$delete_run_ids" ]; then
            echo "No workflow runs identified for deletion."
            rm "$temp_branches_file"
            exit 0
          fi

          # Process unique run IDs for deletion
          delete_run_ids=$(echo "$delete_run_ids" | tr ' ' '\n' | sort -u | grep -v '^\s*$' | tr '\n' ' ')
          echo "Found $(echo "$delete_run_ids" | wc -w) unique workflow runs to clean up."

          for run_id in $delete_run_ids; do
            echo "Processing workflow run ID: $run_id"

            # List artifacts in this workflow run
            artifacts_json=$(curl -s -H "Authorization: token $GITHUB_TOKEN" \
              "https://api.github.com/repos/${owner_repo}/actions/runs/${run_id}/artifacts")
            artifact_ids=$(echo "$artifacts_json" | jq --raw-output '.artifacts[] | .id')

            if [ -z "$artifact_ids" ]; then
              echo "No artifacts found for run $run_id"
              continue
            fi

            for artifact_id in $artifact_ids; do
              echo "Deleting artifact ID: $artifact_id from run $run_id"
              curl -s -X DELETE -H "Authorization: token ${ARTIFACT_DELETE_TOKEN}" \
                "https://api.github.com/repos/${owner_repo}/actions/artifacts/${artifact_id}"
            done
          done

          rm "$temp_branches_file"
          echo "Cleanup complete."
